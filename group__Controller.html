<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>uOFW: Controller Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uOFW
   </div>
   <div id="projectbrief">Reverse engineered PSP kernel 6.60.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Controller Module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceCtrlData.html">SceCtrlData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceCtrlData2.html">SceCtrlData2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceCtrlLatch.html">SceCtrlLatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure represents controller button latch data.  <a href="structSceCtrlLatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceCtrlInputDataTransferHandler.html">SceCtrlInputDataTransferHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1ad26bea0c0a50b6a26b8a64a8f541f1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga1ad26bea0c0a50b6a26b8a64a8f541f1">SceKernelButtonCallbackFunction</a>) (u32 curButtons, u32 lastButtons, void *opt)</td></tr>
<tr class="separator:ga1ad26bea0c0a50b6a26b8a64a8f541f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga52a35dfe35c7e7428b8cc1763529e6c7"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga52a35dfe35c7e7428b8cc1763529e6c7">sceCtrlInit</a> (void)</td></tr>
<tr class="separator:ga52a35dfe35c7e7428b8cc1763529e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b6f484dc61e8210ed5f8ceaccec415"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gac0b6f484dc61e8210ed5f8ceaccec415">sceCtrlEnd</a> (void)</td></tr>
<tr class="separator:gac0b6f484dc61e8210ed5f8ceaccec415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bdb2c2deb872125f9233c7792e581b3"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga9bdb2c2deb872125f9233c7792e581b3">sceCtrlSuspend</a> (void)</td></tr>
<tr class="separator:ga9bdb2c2deb872125f9233c7792e581b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec6a8961ee47304b13326cc89d46971"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga5ec6a8961ee47304b13326cc89d46971">sceCtrlResume</a> (void)</td></tr>
<tr class="separator:ga5ec6a8961ee47304b13326cc89d46971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b19d2e1df02c8d1aa56824e1ceb1d0d"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga4b19d2e1df02c8d1aa56824e1ceb1d0d">sceCtrlSetPollingMode</a> (u8 pollMode)</td></tr>
<tr class="separator:ga4b19d2e1df02c8d1aa56824e1ceb1d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65971f18f3cecdcb2cdd57faac201c00"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga65971f18f3cecdcb2cdd57faac201c00">sceCtrlGetSamplingMode</a> (u8 *pMode)</td></tr>
<tr class="separator:ga65971f18f3cecdcb2cdd57faac201c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5094d2309808580c53de19fb4f08a5d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gad5094d2309808580c53de19fb4f08a5d">sceCtrlSetSamplingMode</a> (u8 mode)</td></tr>
<tr class="separator:gad5094d2309808580c53de19fb4f08a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979f848c7f312c599d2b8b832a36038a"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga979f848c7f312c599d2b8b832a36038a">sceCtrlGetSamplingCycle</a> (u32 *pCycle)</td></tr>
<tr class="separator:ga979f848c7f312c599d2b8b832a36038a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac060595213e8f55054f80ddfad5391"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga6ac060595213e8f55054f80ddfad5391">sceCtrlSetSamplingCycle</a> (u32 cycle)</td></tr>
<tr class="separator:ga6ac060595213e8f55054f80ddfad5391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42adf0cd48e14d8ddd08992431e3f69"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gab42adf0cd48e14d8ddd08992431e3f69">sceCtrlGetIdleCancelKey</a> (u32 *pResetButtonsMake, u32 *pResetButtonsPress, u32 *pResetButtonsMakeHoldMode, u32 *pResetButtonsPressHoldMode)</td></tr>
<tr class="separator:gab42adf0cd48e14d8ddd08992431e3f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abbcfe60f853b497e3652d44b81522e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga4abbcfe60f853b497e3652d44b81522e">sceCtrlSetIdleCancelKey</a> (u32 resetButtonsMake, u32 resetButtonsPress, u32 resetButtonsMakeHoldMode, u32 resetButtonsPressHoldMode)</td></tr>
<tr class="memdesc:ga4abbcfe60f853b497e3652d44b81522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the buttons which, when being pressed, reset the idle timer.  <a href="#ga4abbcfe60f853b497e3652d44b81522e">More...</a><br /></td></tr>
<tr class="separator:ga4abbcfe60f853b497e3652d44b81522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a6a1d81323aee0b8360694c961b3cf"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gad4a6a1d81323aee0b8360694c961b3cf">sceCtrlGetIdleCancelThreshold</a> (s32 *pUnHoldThreshold, s32 *pHoldThreshold)</td></tr>
<tr class="separator:gad4a6a1d81323aee0b8360694c961b3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ec57507d7b9e6f689cba424cad343b"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gab2ec57507d7b9e6f689cba424cad343b">sceCtrlSetIdleCancelThreshold</a> (s32 unHoldThreshold, s32 holdThreshold)</td></tr>
<tr class="separator:gab2ec57507d7b9e6f689cba424cad343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7b45e84899d51a4e720507568e92cab"><td class="memItemLeft" align="right" valign="top">s16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gac7b45e84899d51a4e720507568e92cab">sceCtrlGetSuspendingExtraSamples</a> (void)</td></tr>
<tr class="separator:gac7b45e84899d51a4e720507568e92cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee049e9ce1b88f11ad272bc43269aff"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gabee049e9ce1b88f11ad272bc43269aff">sceCtrlSetSuspendingExtraSamples</a> (s16 suspendSamples)</td></tr>
<tr class="separator:gabee049e9ce1b88f11ad272bc43269aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa41d060f58c708945de4d9c8c9c42b74"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gaa41d060f58c708945de4d9c8c9c42b74">sceCtrl_driver_E467BEC8</a> (u8 externalPort, <a class="el" href="structSceCtrlInputDataTransferHandler.html">SceCtrlInputDataTransferHandler</a> *transferHandler, void *inputSource)</td></tr>
<tr class="separator:gaa41d060f58c708945de4d9c8c9c42b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf">sceCtrlPeekLatch</a> (<a class="el" href="structSceCtrlLatch.html">SceCtrlLatch</a> *pLatch)</td></tr>
<tr class="memdesc:ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latch data.  <a href="#ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf">More...</a><br /></td></tr>
<tr class="separator:ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecb327272afd0b00930e49b53324f98"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga3ecb327272afd0b00930e49b53324f98">sceCtrlReadLatch</a> (<a class="el" href="structSceCtrlLatch.html">SceCtrlLatch</a> *pLatch)</td></tr>
<tr class="memdesc:ga3ecb327272afd0b00930e49b53324f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the latch data.  <a href="#ga3ecb327272afd0b00930e49b53324f98">More...</a><br /></td></tr>
<tr class="separator:ga3ecb327272afd0b00930e49b53324f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb32d820c6f6d8c811b55ff07f97bf0"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga4fb32d820c6f6d8c811b55ff07f97bf0">sceCtrlPeekBufferPositive</a> (<a class="el" href="structSceCtrlData.html">SceCtrlData</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:ga4fb32d820c6f6d8c811b55ff07f97bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by polling (positive logic).  <a href="#ga4fb32d820c6f6d8c811b55ff07f97bf0">More...</a><br /></td></tr>
<tr class="separator:ga4fb32d820c6f6d8c811b55ff07f97bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab308dec3b61c94468f6b89ae39b332c1"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gab308dec3b61c94468f6b89ae39b332c1">sceCtrlPeekBufferNegative</a> (<a class="el" href="structSceCtrlData.html">SceCtrlData</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:gab308dec3b61c94468f6b89ae39b332c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by polling (negative logic).  <a href="#gab308dec3b61c94468f6b89ae39b332c1">More...</a><br /></td></tr>
<tr class="separator:gab308dec3b61c94468f6b89ae39b332c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9aae2af2f71160ebecea78bdcb7da2d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gaf9aae2af2f71160ebecea78bdcb7da2d">sceCtrlReadBufferPositive</a> (<a class="el" href="structSceCtrlData.html">SceCtrlData</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:gaf9aae2af2f71160ebecea78bdcb7da2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by blocking (positive logic).  <a href="#gaf9aae2af2f71160ebecea78bdcb7da2d">More...</a><br /></td></tr>
<tr class="separator:gaf9aae2af2f71160ebecea78bdcb7da2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a14bd3a1fbea5f09c600f8e0f077cfa"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga7a14bd3a1fbea5f09c600f8e0f077cfa">sceCtrlReadBufferNegative</a> (<a class="el" href="structSceCtrlData.html">SceCtrlData</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:ga7a14bd3a1fbea5f09c600f8e0f077cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by blocking (negative logic).  <a href="#ga7a14bd3a1fbea5f09c600f8e0f077cfa">More...</a><br /></td></tr>
<tr class="separator:ga7a14bd3a1fbea5f09c600f8e0f077cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4405850087ce3b0e9799c92b6fe9d691"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga4405850087ce3b0e9799c92b6fe9d691">sceCtrlPeekBufferPositive2</a> (u32 port, <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:ga4405850087ce3b0e9799c92b6fe9d691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by polling (positive logic) with support for wireless controllers.  <a href="#ga4405850087ce3b0e9799c92b6fe9d691">More...</a><br /></td></tr>
<tr class="separator:ga4405850087ce3b0e9799c92b6fe9d691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba5e5feee8d1879f8eff5ca03f76d98"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga1ba5e5feee8d1879f8eff5ca03f76d98">sceCtrlPeekBufferNegative2</a> (u32 port, <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:ga1ba5e5feee8d1879f8eff5ca03f76d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by polling (negative logic) with support for wireless controllers.  <a href="#ga1ba5e5feee8d1879f8eff5ca03f76d98">More...</a><br /></td></tr>
<tr class="separator:ga1ba5e5feee8d1879f8eff5ca03f76d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb8976c0490cd0ecd0fc193874a8ab9"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga5eb8976c0490cd0ecd0fc193874a8ab9">sceCtrlReadBufferPositive2</a> (u32 port, <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:ga5eb8976c0490cd0ecd0fc193874a8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by blocking (positive logic) with support for wireless controllers.  <a href="#ga5eb8976c0490cd0ecd0fc193874a8ab9">More...</a><br /></td></tr>
<tr class="separator:ga5eb8976c0490cd0ecd0fc193874a8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5885a3401196936b321a9a48f78a603"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gaa5885a3401196936b321a9a48f78a603">sceCtrlReadBufferNegative2</a> (u32 port, <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *pData, u8 nBufs)</td></tr>
<tr class="memdesc:gaa5885a3401196936b321a9a48f78a603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves controller state data by blocking (negative logic) with support for wireless controllers.  <a href="#gaa5885a3401196936b321a9a48f78a603">More...</a><br /></td></tr>
<tr class="separator:gaa5885a3401196936b321a9a48f78a603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30bd0932ec2d6557d3ff50792bcae76"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gad30bd0932ec2d6557d3ff50792bcae76">sceCtrlClearRapidFire</a> (u8 slot)</td></tr>
<tr class="separator:gad30bd0932ec2d6557d3ff50792bcae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c6374cc45b7af697b17a9269e17d37"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga57c6374cc45b7af697b17a9269e17d37">sceCtrlSetRapidFire</a> (u8 slot, u32 uiMask, u32 uiTrigger, u32 uiTarget, u8 uiDelay, u8 uiMake, u8 uiBreak)</td></tr>
<tr class="separator:ga57c6374cc45b7af697b17a9269e17d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf40ec0c5149ac3589a6a46b7421db72"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gadf40ec0c5149ac3589a6a46b7421db72">sceCtrlSetAnalogEmulation</a> (u8 slot, u8 aX, u8 aY, u32 uiMake)</td></tr>
<tr class="separator:gadf40ec0c5149ac3589a6a46b7421db72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9174b1924b483a8ea85701447399db"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga9f9174b1924b483a8ea85701447399db">sceCtrlSetButtonEmulation</a> (u8 slot, u32 userButtons, u32 kernelButtons, u32 uiMake)</td></tr>
<tr class="separator:ga9f9174b1924b483a8ea85701447399db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3361c6d71b227660eb0cfbd7360aa6a"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gab3361c6d71b227660eb0cfbd7360aa6a">sceCtrlGetButtonIntercept</a> (u32 buttons)</td></tr>
<tr class="separator:gab3361c6d71b227660eb0cfbd7360aa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bda79d76ef15dbb96aa2ae6e469e4b8"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga6bda79d76ef15dbb96aa2ae6e469e4b8">sceCtrlSetButtonIntercept</a> (u32 buttons, u32 buttonMaskMode)</td></tr>
<tr class="separator:ga6bda79d76ef15dbb96aa2ae6e469e4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d31b522faef3b2f338bbf80d19d5948"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga4d31b522faef3b2f338bbf80d19d5948">sceCtrlSetSpecialButtonCallback</a> (u32 slot, u32 buttonMask, <a class="el" href="group__Controller.html#ga1ad26bea0c0a50b6a26b8a64a8f541f1">SceKernelButtonCallbackFunction</a> callback, void *opt)</td></tr>
<tr class="separator:ga4d31b522faef3b2f338bbf80d19d5948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e7a8b2d7d4fe5b6a40b0051d8bd3ab"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga38e7a8b2d7d4fe5b6a40b0051d8bd3ab">sceCtrl_driver_6C86AF22</a> (s32 arg1)</td></tr>
<tr class="separator:ga38e7a8b2d7d4fe5b6a40b0051d8bd3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b60f5463ef60ad75383a6eae6c4f28"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#ga03b60f5463ef60ad75383a6eae6c4f28">sceCtrl_driver_5886194C</a> (s8 arg1)</td></tr>
<tr class="separator:ga03b60f5463ef60ad75383a6eae6c4f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee332af425275a0dbf362e4cbe8abd4"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Controller.html#gacee332af425275a0dbf362e4cbe8abd4">sceCtrlUpdateCableTypeReq</a> (void)</td></tr>
<tr class="separator:gacee332af425275a0dbf362e4cbe8abd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Copyright (C) 2011 - 2015 The uOFW team See the file COPYING for copying permission. Controller (joystick) management. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1ad26bea0c0a50b6a26b8a64a8f541f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SceKernelButtonCallbackFunction) (u32 curButtons, u32 lastButtons, void *opt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The callback function used by <a class="el" href="group__Controller.html#ga4d31b522faef3b2f338bbf80d19d5948">sceCtrlSetSpecialButtonCallback()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga6104b860a63a93d46fa4348f596e8548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for the digital controller buttons in positive logic.</p>
<dl class="section note"><dt>Note</dt><dd>SCE_CTRL_INTERCEPTED, SCE_CTRL_WLAN_UP, SCE_CTRL_REMOTE, SCE_CTRL_VOLUP, SCE_CTRL_VOLDOWN, SCE_CTRL_SCREEN, SCE_CTRL_NOTE, SCE_CTRL_DISC, SCE_CTRL_MS can only be read in kernel mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548ad8cd1e340f5e13979b4cdefcf0487691"></a>SCE_CTRL_SELECT&#160;</td><td class="fielddoc">
<p>Select button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a1fb3c7b2e36870fca7507014d124e19b"></a>SCE_CTRL_L3&#160;</td><td class="fielddoc">
<p>DS3 L3 button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a3d1d42802f5ebd0a312e431285bd8dfc"></a>SCE_CTRL_R3&#160;</td><td class="fielddoc">
<p>DS3 R3 button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a8728e23635e8a8cb66bba777182be4de"></a>SCE_CTRL_START&#160;</td><td class="fielddoc">
<p>Start button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a4275a1d4d7b662514f3258423e0fd770"></a>SCE_CTRL_UP&#160;</td><td class="fielddoc">
<p>Up D-Pad button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a69bf7b49f9cbe3fd1c3a6cf615d69dc1"></a>SCE_CTRL_RIGHT&#160;</td><td class="fielddoc">
<p>Right D-Pad button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a152892bee6c021fb3a41aa1d753ca338"></a>SCE_CTRL_DOWN&#160;</td><td class="fielddoc">
<p>Down D-Pad button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a2cead064cd16d43807e6a2445bf8a362"></a>SCE_CTRL_LEFT&#160;</td><td class="fielddoc">
<p>Left D-Pad button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a04799c8e184d2ae7f7df6633fff89f86"></a>SCE_CTRL_LTRIGGER&#160;</td><td class="fielddoc">
<p>Left trigger. This accounts for the DS3 L2 trigger as well. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a8a8396d93981d7ac967a7ae405dbd990"></a>SCE_CTRL_RTRIGGER&#160;</td><td class="fielddoc">
<p>Right trigger. This accounts for the DS3 R2 trigger as well. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a8d2136d1eee680bb70a1a82b0f78ddc2"></a>SCE_CTRL_L1TRIGGER&#160;</td><td class="fielddoc">
<p>DS3 L1 trigger. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a1e3b8e9ca6a6e6c7c9f2c8f40a677d9c"></a>SCE_CTRL_R1TRIGGER&#160;</td><td class="fielddoc">
<p>DS3 R1 trigger. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a9debd2be025f0e081238399dd396d456"></a>SCE_CTRL_TRIANGLE&#160;</td><td class="fielddoc">
<p>Triangle button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548acc26a837d4e5a5cfb62adaf48ddead2c"></a>SCE_CTRL_CIRCLE&#160;</td><td class="fielddoc">
<p>Circle button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a477d551daa482e03598b67aaf4466923"></a>SCE_CTRL_CROSS&#160;</td><td class="fielddoc">
<p>Cross button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548af935d4e61120671b2acdf6cee2f776e6"></a>SCE_CTRL_SQUARE&#160;</td><td class="fielddoc">
<p>Square button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a12085cf461189faeb160ccd99affe06d"></a>SCE_CTRL_INTERCEPTED&#160;</td><td class="fielddoc">
<p>If this bit is set, then controller input is being intercepted by the system software or another application. For example, this is the case when the PSP's HOME menu is being shown. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a1fe78e8242046ce4ac16f34cd9088827"></a>SCE_CTRL_HOLD&#160;</td><td class="fielddoc">
<p>Hold button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a4473282f9f5057d35c8ef3b102d7aaf3"></a>SCE_CTRL_WLAN_UP&#160;</td><td class="fielddoc">
<p>W-LAN switch up. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a0a31abd94110a8cdb07dedd838e28bd9"></a>SCE_CTRL_REMOTE&#160;</td><td class="fielddoc">
<p>Remote hold position. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a436d88aeb4ce14521088bd556eb863cc"></a>SCE_CTRL_VOLUP&#160;</td><td class="fielddoc">
<p>Volume up button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548aeab7d0c864db59474af654aad4427963"></a>SCE_CTRL_VOLDOWN&#160;</td><td class="fielddoc">
<p>Volume down button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a54ea84024e88b5408c772fe41d9d4c4b"></a>SCE_CTRL_SCREEN&#160;</td><td class="fielddoc">
<p>Screen button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548add58de33467132daa6ef656a7a4bda8f"></a>SCE_CTRL_NOTE&#160;</td><td class="fielddoc">
<p>Music Note button. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548a621e06863028d8003568bfa3e89ada9b"></a>SCE_CTRL_DISC&#160;</td><td class="fielddoc">
<p>Disc present. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6104b860a63a93d46fa4348f596e8548ad5927b8379706451759520fc7f38548c"></a>SCE_CTRL_MS&#160;</td><td class="fielddoc">
<p>Memory stick present. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga62ab7ac206d0514d11e60309f9621fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Controller.html#ga62ab7ac206d0514d11e60309f9621fb6">SceCtrlPadInputMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controller input modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga62ab7ac206d0514d11e60309f9621fb6afa4b32e51f6ab1908737fee4db12fb5e"></a>SCE_CTRL_INPUT_DIGITAL_ONLY&#160;</td><td class="fielddoc">
<p>Digital input only. No recognizing of analog input. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga62ab7ac206d0514d11e60309f9621fb6a6d7fec611a11883cbafed2240dfb162f"></a>SCE_CTRL_INPUT_DIGITAL_ANALOG&#160;</td><td class="fielddoc">
<p>Recognizing of both digital and analog input. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga17d4f10bb96061a642c0a2d0dad006ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Controller.html#ga17d4f10bb96061a642c0a2d0dad006ca">SceCtrlPadPollMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controller input poll modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga17d4f10bb96061a642c0a2d0dad006caa3b7e60cb4f40ee10c673406e3c10ffc8"></a>SCE_CTRL_POLL_INACTIVE&#160;</td><td class="fielddoc">
<p>No controller input is recognized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga17d4f10bb96061a642c0a2d0dad006caa6129b973b49202993ec157eb9d6eda70"></a>SCE_CTRL_POLL_ACTIVE&#160;</td><td class="fielddoc">
<p>Controller input is recognized. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga184f67736f5be2b59a20e974799aaee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Controller.html#ga184f67736f5be2b59a20e974799aaee6">SceCtrlPort</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the type of input data to be obtained. </p>

</div>
</div>
<a class="anchor" id="ga9aca46c5af11b73d3a00e6911725bf01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Controller.html#ga9aca46c5af11b73d3a00e6911725bf01">SceCtrlPadButtonMaskMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Button mask settings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9aca46c5af11b73d3a00e6911725bf01a01dc8a59e089dd75a7e786890710552e"></a>SCE_CTRL_MASK_NO_MASK&#160;</td><td class="fielddoc">
<p>No mask for the specified buttons. Button input is normally recognized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9aca46c5af11b73d3a00e6911725bf01aeb8d298533f9c48b1eaf446d1afbe0a5"></a>SCE_CTRL_MASK_IGNORE_BUTTONS&#160;</td><td class="fielddoc">
<p>The specified buttons are ignored, that means even if these buttons are pressed by the user they won't be shown as pressed internally. You can only block user buttons for applications running in User Mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9aca46c5af11b73d3a00e6911725bf01a00ffbcca27c08d89e3fbd058e15e202f"></a>SCE_CTRL_MASK_APPLY_BUTTONS&#160;</td><td class="fielddoc">
<p>The specified buttons show up as being pressed, even if the user does not press them. You can only turn ON user buttons for applications running in User Mode. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga52a35dfe35c7e7428b8cc1763529e6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the controller device. Bind the controller driver to the controller device.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0b6f484dc61e8210ed5f8ceaccec415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlEnd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates the controller device. Unbind the controller driver from the controller device.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bdb2c2deb872125f9233c7792e581b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSuspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspends the controller driver and put the controller device into a low-power state.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ec6a8961ee47304b13326cc89d46971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlResume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes the controller driver after and bring the controller device back from a low-power state.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b19d2e1df02c8d1aa56824e1ceb1d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlSetPollingMode </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>pollMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/disables controller device input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollMode</td><td>One of <a class="el" href="group__Controller.html#ga17d4f10bb96061a642c0a2d0dad006ca">SceCtrlPadPollMode</a>. If set to 0, no button/analog input is recognized. Set to 1 to enable button/analog input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65971f18f3cecdcb2cdd57faac201c00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlGetSamplingMode </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>pMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current controller device input mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMode</td><td>Pointer to an u8 variable which is to receive the current controller mode. One of <a class="el" href="group__Controller.html#ga62ab7ac206d0514d11e60309f9621fb6">SceCtrlPadInputMode</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="gad5094d2309808580c53de19fb4f08a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetSamplingMode </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the controller device input mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The new controller input mode. One of <a class="el" href="group__Controller.html#ga62ab7ac206d0514d11e60309f9621fb6">SceCtrlPadInputMode</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous input mode on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga979f848c7f312c599d2b8b832a36038a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlGetSamplingCycle </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>pCycle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current update interval of the internal controller data buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCycle</td><td>Pointer to an u32 variable which is to receive the current update interval (in microseconds).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ac060595213e8f55054f80ddfad5391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetSamplingCycle </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>cycle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the update frequency of the internal controller buffer. Default update interval is the VBlank interrupt (approximately 60 times per second).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycle</td><td>The new interval between two samplings of controller attributes in microseconds. Setting to 0 enables the VBlank-Interrupt-Update process. If you want to set an own interval for updating the internal controller buffers, cycle has to in the range of 5555 - 20000 (the range from about 180 Hz to 50 Hz). This will disable the VBlank-Interrupt-Update process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous cycle on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gab42adf0cd48e14d8ddd08992431e3f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlGetIdleCancelKey </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>pResetButtonsMake</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>pResetButtonsPress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>pResetButtonsMakeHoldMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>pResetButtonsPressHoldMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the different cancel-idle-timer buttons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pResetButtonsMake</td><td>Pointer to an u32 variable which is to receive the buttons resetting the idle timer when being pressed a new time (not already being pressed). Not used when the system is in HOLD mode. </td></tr>
    <tr><td class="paramname">pResetButtonsPress</td><td>Pointer to an u32 variable which is to receive the buttons resetting the idle timer when being pressed. Not used when the system is in HOLD mode. </td></tr>
    <tr><td class="paramname">pResetButtonsMakeHoldMode</td><td>Pointer to an u32 variable which is to receive the buttons resetting the idle timer when being pressed a new time (not already being pressed). Used when the system is in HOLD mode. </td></tr>
    <tr><td class="paramname">pResetButtonsPressHoldMode</td><td>Pointer to an u32 variable which is to receive the buttons resetting the idle timer when being pressed a new time. Used when the system is in HOLD mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4abbcfe60f853b497e3652d44b81522e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlSetIdleCancelKey </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>resetButtonsMake</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>resetButtonsPress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>resetButtonsMakeHoldMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>resetButtonsPressHoldMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the buttons which, when being pressed, reset the idle timer. </p>
<p>This function lets you specify buttons which reset the idle timer. If multiple buttons are specified the timer can be resetted by simply pressing one of the specified buttons. A button combination is also possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetButtonsMake</td><td>Buttons which will reset the timer if pressed. One or more of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. If you keep pressing one or more of these buttons after resetting the timer, they will not reset the timer anymore. You will have to release the buttons first, before they can reset it again. In case HOLD mode is active, pressing these buttons will not reset the timer. </td></tr>
    <tr><td class="paramname">resetButtonsPress</td><td>Buttons which will reset the timer if pressed. One or more of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. As long as you press one of these buttons, the timer is resetted. In case HOLD mode is active, pressing these buttons will not reset the timer. </td></tr>
    <tr><td class="paramname">resetButtonsMakeHoldMode</td><td>Buttons which will reset the timer if pressed while HOLD mode is active. One or more of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. If you keep pressing these buttons after resetting the timer, they will not reset it anymore. You will have to release the buttons first, before they can reset the timer again. </td></tr>
    <tr><td class="paramname">resetButtonsPressHoldMode</td><td>Buttons which will reset the timer if pressed while HOLD mode is active. One or more of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. As long as you press one of these buttons, the timer is resetted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Pressing the START button will reset the idle timer. Button needs to be released and pressed again to reset the</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// idle timer another time. HOLD mode has to be inactive.</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// Pressing the SELECT button will reset the idle timer. The button can be kept pressed (held down) to keep resetting</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// the idle timer. HOLD mode has to be inactive.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;sceCtrlSetIdleCancelKey(SCE_CTRL_START, SCE_CTRL_SELECT, 0, 0);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gad4a6a1d81323aee0b8360694c961b3cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlGetIdleCancelThreshold </td>
          <td>(</td>
          <td class="paramtype">s32 *&#160;</td>
          <td class="paramname"><em>pUnHoldThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32 *&#160;</td>
          <td class="paramname"><em>pHoldThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the idle timer cancel movement threshold values for the analog stick.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUnHoldThreshold</td><td>Pointer to a s32 variable which is to receive the treshold value when HOLD mode is inactive. </td></tr>
    <tr><td class="paramname">pHoldThreshold</td><td>Pointer to a s32 variable which is to receive the treshold value when HOLD mode is active.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gab2ec57507d7b9e6f689cba424cad343b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetIdleCancelThreshold </td>
          <td>(</td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>unHoldThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>holdThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets analog stick movement threshold values for cancelling the idle timer. In case SCE_CTRL_INPUT_DIGITAL_ONLY is set as the input mode for the controller, analog stick movements will not result in cancelling the idle timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unHoldThreshold</td><td>Movement needed by the analog stick to reset the idle timer. Used when HOLD mode is inactive. Set between 1 - 128 to specify the movement on either axis. Set to 0 for idle timer to be canceled even if the analog stick is not moved (that is, the idle timer itself stops running). Specify SCE_CTRL_IDLE_CANCEL_TRESHOLD_NO_CANCELLATION for analog stick movement to not cancel the idle timer. </td></tr>
    <tr><td class="paramname">holdThreshold</td><td>Movement needed by the analog stick to reset the idle timer. Used when HOLD mode is active. Set between 1 - 128 to specify the movement on either axis. Set to 0 for idle timer to be canceled even if the analog stick is not moved (that is, the idle timer itself stops running). Specify SCE_CTRL_IDLE_CANCEL_TRESHOLD_NO_CANCELLATION for analog stick movement to not cancel the idle timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7b45e84899d51a4e720507568e92cab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16 sceCtrlGetSuspendingExtraSamples </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of VBlanks which will be waited for when the PSP device is being suspended.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of VBlanks to wait for. </dd></dl>

</div>
</div>
<a class="anchor" id="gabee049e9ce1b88f11ad272bc43269aff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetSuspendingExtraSamples </td>
          <td>(</td>
          <td class="paramtype">s16&#160;</td>
          <td class="paramname"><em>suspendSamples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a number of VBlanks which will be waited for when the PSP device is being suspended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suspendSamples</td><td>The number of VBlanks. Between 0 - 300.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa41d060f58c708945de4d9c8c9c42b74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrl_driver_E467BEC8 </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>externalPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceCtrlInputDataTransferHandler.html">SceCtrlInputDataTransferHandler</a> *&#160;</td>
          <td class="paramname"><em>transferHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>inputSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets up internal controller buffers to receive external input data. Each input mode has its own set of buffers. These buffers are of type <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a>. Note: This function has to be called initially in order to obtain external input data via the corresponding Peek/Read functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">externalPort</td><td>Pass a valid element of <a class="el" href="group__Controller.html#ga184f67736f5be2b59a20e974799aaee6">SceCtrlPort</a> (either 1 or 2). </td></tr>
    <tr><td class="paramname">transferHandler</td><td>Pointer to a <a class="el" href="structSceCtrlInputDataTransferHandler.html">SceCtrlInputDataTransferHandler</a> containing a function to copy the <code>inputSource</code> into the PSP's controller buffers. </td></tr>
    <tr><td class="paramname">inputSource</td><td>Pointer to buffer containing the Controller input data to copy to the PSP's controller buffers. It is passed as the source argument to the given transfer function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlPeekLatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceCtrlLatch.html">SceCtrlLatch</a> *&#160;</td>
          <td class="paramname"><em>pLatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latch data. </p>
<p>This function reads the latch data collected by the controller service. At each sampling interval, the controller service compares the new pressed/released button states with the previously sampled pressed button states and stores that comparison as latch data.</p>
<p>Compared to <a class="el" href="group__Controller.html#ga3ecb327272afd0b00930e49b53324f98" title="Gets the latch data. ">sceCtrlReadLatch()</a>, calling this API will not result in clearing the internal latch data. As such, the data returned is the accumulated latch data since the last time <a class="el" href="group__Controller.html#ga3ecb327272afd0b00930e49b53324f98" title="Gets the latch data. ">sceCtrlReadLatch()</a> was called. Consequently, the returned data should not be relied on whether a button is currently in a pressed or released state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLatch</td><td>Pointer to a <a class="el" href="structSceCtrlLatch.html" title="This structure represents controller button latch data. ">SceCtrlLatch</a> variable which is to receive the accumulated button latch data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of times the controller service performed sampling since the last time <a class="el" href="group__Controller.html#ga3ecb327272afd0b00930e49b53324f98" title="Gets the latch data. ">sceCtrlReadLatch()</a> was called. </dd>
<dd>
&lt; 0 on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSceCtrlLatch.html" title="This structure represents controller button latch data. ">SceCtrlLatch</a> </dd>
<dd>
<a class="el" href="group__Controller.html#ga3ecb327272afd0b00930e49b53324f98" title="Gets the latch data. ">sceCtrlReadLatch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ecb327272afd0b00930e49b53324f98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlReadLatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceCtrlLatch.html">SceCtrlLatch</a> *&#160;</td>
          <td class="paramname"><em>pLatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the latch data. </p>
<p>This function reads the most recent latch data collected by the controller service. At each sampling interval, the controller service compares the new pressed/released button states with the previously sampled pressed button states and stores that comparison as latch data.</p>
<p>Compared to <a class="el" href="group__Controller.html#ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf" title="Gets the latch data. ">sceCtrlPeekLatch()</a>, calling this API will result in clearing the internal latch data. As such, calling code might have to explicitly wait for the controller service to update its collected latch data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLatch</td><td>Pointer to a <a class="el" href="structSceCtrlLatch.html" title="This structure represents controller button latch data. ">SceCtrlLatch</a> variable which is to receive the current button latch data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of times the controller service performed sampling since the last time <a class="el" href="group__Controller.html#ga3ecb327272afd0b00930e49b53324f98" title="Gets the latch data. ">sceCtrlReadLatch()</a> was called. </dd>
<dd>
&lt; 0 on error.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;SceCtrlLatch latchData;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;while (1) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    // Obtain latch data</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    sceCtrlReadLatch(&amp;latchData);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    if (latchData.buttonMake &amp; SCE_CTRL_CROSS)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        // The Cross button has just been pressed (transition from &#39;released&#39; state to &#39;pressed&#39; state)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    if (latchData.buttonPress &amp; SCE_CTRL_SQUARE)</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        // The Square button is currently in the &#39;pressed&#39; state</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;   if (latchData.buttonBreak &amp; SCE_CTRL_TRIANGLE)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;   {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;       // The Trangle button has just been released (transition from &#39;pressed&#39; state to &#39;released&#39; state)</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;   }</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;   if (latchData.buttonRelease &amp; SCE_CTRL_CIRCLE)</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;   {</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;       // The Circle button is currently in the &#39;released&#39; state</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;   }</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;   // As we clear the internal latch data with the ReadLatch() call, we can explicitly wait for the VBLANK interval</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;   // to give the controller service the time it needs to collect new latch data again. This guarantees the next call</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;   // to sceCtrlReadLatch() will return collected data again.</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   //</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;   // Note: The sceCtrlReadBuffer*() APIs are implicitly waiting for a VBLANK interval if necessary.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   sceDisplayWaitVBlank();</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;}</div></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSceCtrlLatch.html" title="This structure represents controller button latch data. ">SceCtrlLatch</a> </dd>
<dd>
<a class="el" href="group__Controller.html#ga3a3ffd1ee4d1d6e93dfb95b5df8dfaaf" title="Gets the latch data. ">sceCtrlPeekLatch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fb32d820c6f6d8c811b55ff07f97bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlPeekBufferPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceCtrlData.html">SceCtrlData</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by polling (positive logic). </p>
<p>This function obtains button data stored in the internal controller buffers. Does not wait for the next update interval to be performed. The obtained data will be the latest transfered button data into the internal controller buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData.html">SceCtrlData</a> variables to receive controller state data. The obtained button data is represented in positive logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;SceCtrlData data;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;sceCtrlSetSamplingCycle(0);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;sceCtrlSetSamplingMode(SCE_CTRL_INPUT_DIGITAL_ANALOG);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;while (1) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;       sceCtrlPeekBufferPositive(&amp;data, 1); </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;       // Cross button pressed</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;       if (data.buttons &amp; SCE_CTRL_CROSS) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;           // do something</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;       }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gab308dec3b61c94468f6b89ae39b332c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlPeekBufferNegative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceCtrlData.html">SceCtrlData</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by polling (negative logic). </p>
<p>This fucntion obtains button data stored in the internal controller buffers. Does not wait for the next update interval to be performed. The obtained data will be the latest transfered button data into the internal controller buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData.html">SceCtrlData</a> variables to receive controller state data. The obtained button data is represented in negative logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;SceCtrlData data;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;sceCtrlSetSamplingCycle(0);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;sceCtrlSetSamplingMode(SCE_CTRL_INPUT_DIGITAL_ANALOG);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;while (1) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;       sceCtrlPeekBufferNegative(&amp;data, 1); </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;       // Cross button pressed</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;       if (data.buttons &amp; ~SCE_CTRL_CROSS) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;           // do something</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;       }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9aae2af2f71160ebecea78bdcb7da2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlReadBufferPositive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceCtrlData.html">SceCtrlData</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by blocking (positive logic). </p>
<p>This function obtains button data stored in the internal controller buffers. Waits for the next update interval before obtaining the data. The read data is the newest transfered data into the internal controller buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData.html">SceCtrlData</a> variables to receive controller state data. The obtained data is represented in positive logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a14bd3a1fbea5f09c600f8e0f077cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlReadBufferNegative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceCtrlData.html">SceCtrlData</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by blocking (negative logic). </p>
<p>This function obtains button data stored in the internal controller buffers. Waits for the next update interval before obtaining the data. The read data is the newest transfered data into the internal controller buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData.html">SceCtrlData</a> variables to receive controller state data. The obtained data is represented in negative logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4405850087ce3b0e9799c92b6fe9d691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlPeekBufferPositive2 </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by polling (positive logic) with support for wireless controllers. </p>
<p>This function Obtains button data stored in the internal controller buffers. Waits for the next update interval before obtaining the data. The read data is the newest transfered data into the internal controller buffers and can contain input state provided by external input devices such as a wireless controller.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="group__Controller.html#gaa41d060f58c708945de4d9c8c9c42b74">sceCtrl_driver_E467BEC8()</a> before initial use of this API or its related ones.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Pass a valid element of <a class="el" href="group__Controller.html#ga184f67736f5be2b59a20e974799aaee6">SceCtrlPort</a> (either 1 or 2). </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> variables to receive controller state data. The obtained button data is represented in positive logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ba5e5feee8d1879f8eff5ca03f76d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlPeekBufferNegative2 </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by polling (negative logic) with support for wireless controllers. </p>
<p>This function obtains button data stored in the internal controller buffers. Waits for the next update interval before obtaining the data. The read data is the newest transfered data into the internal controller buffers and can contain input state provided by external input devices such as a wireless controller.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="group__Controller.html#gaa41d060f58c708945de4d9c8c9c42b74">sceCtrl_driver_E467BEC8()</a> before initial use of this API or its related ones.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Pass a valid element of <a class="el" href="group__Controller.html#ga184f67736f5be2b59a20e974799aaee6">SceCtrlPort</a> (either 1 or 2). </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> variables to receive controller state data. The obtained button data is represented in negative logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5eb8976c0490cd0ecd0fc193874a8ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlReadBufferPositive2 </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by blocking (positive logic) with support for wireless controllers. </p>
<p>This function obtains button data stored in the internal controller buffers. Waits for the next update interval before obtaining the data. The read data is the newest transfered data into the internal controller buffers and can contain input state provided by external input devices such as a wireless controller.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="group__Controller.html#gaa41d060f58c708945de4d9c8c9c42b74">sceCtrl_driver_E467BEC8()</a> before initial use of this API or its related ones.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Pass a valid element of <a class="el" href="group__Controller.html#ga184f67736f5be2b59a20e974799aaee6">SceCtrlPort</a> (either 1 or 2). </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> variables to receive controller state data. The obtained button data is represented in positive logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5885a3401196936b321a9a48f78a603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlReadBufferNegative2 </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>nBufs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves controller state data by blocking (negative logic) with support for wireless controllers. </p>
<p>This function obtains button data stored in the internal controller buffers. Waits for the next update interval before obtaining the data. The read data is the newest transfered data into the internal controller buffers and can contain input state provided by external input devices such as a wireless controller.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You need to call <a class="el" href="group__Controller.html#gaa41d060f58c708945de4d9c8c9c42b74">sceCtrl_driver_E467BEC8()</a> before initial use of this API or its related ones.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Pass a valid element of <a class="el" href="group__Controller.html#ga184f67736f5be2b59a20e974799aaee6">SceCtrlPort</a> (either 1 or 2). </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to one or more <a class="el" href="structSceCtrlData2.html">SceCtrlData2</a> variables to receive controller state data. The obtained button data is represented in negative logic. </td></tr>
    <tr><td class="paramname">nBufs</td><td>The number of internal controller buffers to read. There are 64 internal controller buffers which can be read. Has to be set to a value in the range of 1 - 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of read internal controller buffers on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gad30bd0932ec2d6557d3ff50792bcae76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlClearRapidFire </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a rapid-fire button event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot of the event to clear. Between 0 - 15.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga57c6374cc45b7af697b17a9269e17d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetRapidFire </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>uiMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>uiTrigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>uiTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>uiDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>uiMake</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>uiBreak</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies a rapid-fire event for one or more buttons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot used to set the custom values. Between 0 - 15. Up to 16 slots can be used. </td></tr>
    <tr><td class="paramname">uiMask</td><td>Comparison mask of the button operation for rapid-fire trigger. In order for the <code>uiTrigger</code> buttons to trigger the event, they need to be included in these buttons. One or more buttons of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. </td></tr>
    <tr><td class="paramname">uiTrigger</td><td>The buttons which will start the rapid fire event for the specified <code>uiTarget</code> buttons when being pressed. </td></tr>
    <tr><td class="paramname">uiTarget</td><td>The buttons for which the rapid-fire event will be applied to. User mode buttons only. <code>uiMake</code> and <code>uiBreak</code> define the rapid-fire cycle. </td></tr>
    <tr><td class="paramname">uiDelay</td><td>Dead time of rapid-fire trigger (sampling count). Specifies the rapid-fire start timing. It will only be applied for the first ON period of a (not cancelled) rapid-fire event. Set to 0 - 63. </td></tr>
    <tr><td class="paramname">uiMake</td><td>The press time for the <code>uiTarget</code> buttons. This "ON-time" is set after <code>uiDelay</code> was applied and the <code>uiTrigger</code> buttons were turned OFF. It will be applied for as long as the same rapid fire event is called without a break (i.e. pressing of a different PSP button). Set to 0 - 63. If set to 0, the <code>uiTarget</code> button(s) will be turned ON for one sampling count. </td></tr>
    <tr><td class="paramname">uiBreak</td><td>The release time for <code>uiTarget</code> buttons. This "OFF-time" is set after <code>uiDelay</code> was applied. It will be applied as long as the same rapid fire event is called without a break (i.e. the pressing of a different PSP button). Set to 0 - 63. If set to 0, the <code>uiTarget</code> button will be turned OFF for 64 consecutive sampling counts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// A rapid fire event for the R-button while the D-Pad-Up button is being pressed.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// R-button will be turned ON and OFF for 64 internal controller buffer updates in both cases </div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// (as long as D-Pad-Up is pressed).</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;sceCtrlSetRapidFire(0, SCE_CTRL_UP, SCE_CTRL_UP, SCE_CTRL_RTRIGGER, 63, 63, 63);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// A rapid fire event for the R-button while the D-Pad-Up button is being pressed.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// R-button will be turned OFF and ON for 40 internal controller buffer updates in both cases </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;// (as long as D-Pad-Up is pressed).</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;sceCtrlSetRapidFire(0, SCE_CTRL_UP, SCE_CTRL_UP, SCE_CTRL_RTRIGGER, 0, 40, 40);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf40ec0c5149ac3589a6a46b7421db72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetAnalogEmulation </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>aX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>aY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>uiMake</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emulates values for the analog pad's X- and Y-axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot used to set the custom values. Between 0 - 3. If multiple slots are used, their settings are combined. </td></tr>
    <tr><td class="paramname">aX</td><td>New emulated value for the X-axis. Between 0 - 0xFF. </td></tr>
    <tr><td class="paramname">aY</td><td>New emulate value for the Y-axis. Between 0 - 0xFF. </td></tr>
    <tr><td class="paramname">uiMake</td><td>Specifies the duration of the emulation. Meassured in sampling counts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f9174b1924b483a8ea85701447399db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetButtonEmulation </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>userButtons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>kernelButtons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>uiMake</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emulates buttons for the digital pad.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot used to set the custom values. Between 0 - 3. If multiple slots are used, their settings are combined. </td></tr>
    <tr><td class="paramname">userButtons</td><td>Emulated user buttons of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. You cannot emulate kernel buttons and the emulated buttons will only be applied for applications running in user mode. </td></tr>
    <tr><td class="paramname">kernelButtons</td><td>Emulated buttons of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a> (you can emulate both user and kernel buttons). The emulated buttons will only be applied for applications running in kernel mode. </td></tr>
    <tr><td class="paramname">uiMake</td><td>Specifies the duration of the emulation. Meassured in sampling counts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gab3361c6d71b227660eb0cfbd7360aa6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlGetButtonIntercept </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>buttons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the button mask settings applied to PSP buttons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttons</td><td>The buttons to check for. One or more buttons of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The button mask mode for the given buttons. One of <a class="el" href="group__Controller.html#ga9aca46c5af11b73d3a00e6911725bf01">SceCtrlPadButtonMaskMode</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bda79d76ef15dbb96aa2ae6e469e4b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlSetButtonIntercept </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>buttons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>buttonMaskMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a button mask mode for one or more buttons. You can only mask user mode buttons in user applications. Masking of kernel mode buttons is ignored as well as buttons used in kernel mode applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttons</td><td>The button value for which the button mask mode will be applied for. One or more buttons of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. </td></tr>
    <tr><td class="paramname">buttonMaskMode</td><td>Specifies the type of the button mask. One of <a class="el" href="group__Controller.html#ga9aca46c5af11b73d3a00e6911725bf01">SceCtrlPadButtonMaskMode</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous button mask type for the given buttons. One of <a class="el" href="group__Controller.html#ga9aca46c5af11b73d3a00e6911725bf01">SceCtrlPadButtonMaskMode</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Block user mode buttons for User mode applications</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sceCtrlSetButtonIntercept(0xFFFF, SCE_CTRL_MASK_IGNORE_BUTTONS);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// Do something</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// Remove block from user mode buttons for User mode applications</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;sceCtrlSetButtonIntercept(0xFFFF, SCE_CTRL_MASK_NO_MASK);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d31b522faef3b2f338bbf80d19d5948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceCtrlSetSpecialButtonCallback </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>buttonMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Controller.html#ga1ad26bea0c0a50b6a26b8a64a8f541f1">SceKernelButtonCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a button callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot used to register the callback. Between 0 - 3. </td></tr>
    <tr><td class="paramname">buttonMask</td><td>Bitwise OR'ed button values which will be checked for being pressed. One or more buttons of <a class="el" href="group__Controller.html#ga6104b860a63a93d46fa4348f596e8548">SceCtrlPadButtons</a>. </td></tr>
    <tr><td class="paramname">callback</td><td>Pointer to the callback function handling the button callbacks. </td></tr>
    <tr><td class="paramname">opt</td><td>Optional user argument. Passed to the callback function as its third argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38e7a8b2d7d4fe5b6a40b0051d8bd3ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrl_driver_6C86AF22 </td>
          <td>(</td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>Unknown argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03b60f5463ef60ad75383a6eae6c4f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrl_driver_5886194C </td>
          <td>(</td>
          <td class="paramtype">s8&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>Unknown argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="gacee332af425275a0dbf362e4cbe8abd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceCtrlUpdateCableTypeReq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unknown.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 5 2021 19:28:06 for uOFW by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
